// File: @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol


// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)

pragma solidity ^0.8.2;


/**
 * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
 * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an
 * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
 * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
 *
 * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be
 * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in
 * case an upgrade adds a module that needs to be initialized.
 *
 * For example:
 *
 * [.hljs-theme-light.nopadding]
 * ```
 * contract MyToken is ERC20Upgradeable {
 *     function initialize() initializer public {
 *         __ERC20_init("MyToken", "MTK");
 *     }
 * }
 * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {
 *     function initializeV2() reinitializer(2) public {
 *         __ERC20Permit_init("MyToken");
 *     }
 * }
 * ```
 *
 * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
 * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.
 *
 * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
 * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
 *
 * [CAUTION]
 * ====
 * Avoid leaving a contract uninitialized.
 *
 * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation
 * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke
 * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:
 *
 * [.hljs-theme-light.nopadding]
 * ```
 * /// @custom:oz-upgrades-unsafe-allow constructor
 * constructor() {
 *     _disableInitializers();
 * }
 * ```
 * ====
 */
abstract contract Initializable {
    /**
     * @dev Indicates that the contract has been initialized.
     * @custom:oz-retyped-from bool
     */
    uint8 private _initialized;

    /**
     * @dev Indicates that the contract is in the process of being initialized.
     */
    bool private _initializing;

    /**
     * @dev Triggered when the contract has been initialized or reinitialized.
     */
    event Initialized(uint8 version);

    /**
     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,
     * `onlyInitializing` functions can be used to initialize parent contracts.
     *
     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a
     * constructor.
     *
     * Emits an {Initialized} event.
     */
    modifier initializer() {
        bool isTopLevelCall = !_initializing;
        require(
            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),
            "Initializable: contract is already initialized"
        );
        _initialized = 1;
        if (isTopLevelCall) {
            _initializing = true;
        }
        _;
        if (isTopLevelCall) {
            _initializing = false;
            emit Initialized(1);
        }
    }

    /**
     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the
     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be
     * used to initialize parent contracts.
     *
     * A reinitializer may be used after the original initialization step. This is essential to configure modules that
     * are added through upgrades and that require initialization.
     *
     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`
     * cannot be nested. If one is invoked in the context of another, execution will revert.
     *
     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in
     * a contract, executing them in the right order is up to the developer or operator.
     *
     * WARNING: setting the version to 255 will prevent any future reinitialization.
     *
     * Emits an {Initialized} event.
     */
    modifier reinitializer(uint8 version) {
        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");
        _initialized = version;
        _initializing = true;
        _;
        _initializing = false;
        emit Initialized(version);
    }

    /**
     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the
     * {initializer} and {reinitializer} modifiers, directly or indirectly.
     */
    modifier onlyInitializing() {
        require(_initializing, "Initializable: contract is not initializing");
        _;
    }

    /**
     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.
     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized
     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called
     * through proxies.
     *
     * Emits an {Initialized} event the first time it is successfully executed.
     */
    function _disableInitializers() internal virtual {
        require(!_initializing, "Initializable: contract is initializing");
        if (_initialized < type(uint8).max) {
            _initialized = type(uint8).max;
            emit Initialized(type(uint8).max);
        }
    }

    /**
     * @dev Returns the highest version that has been initialized. See {reinitializer}.
     */
    function _getInitializedVersion() internal view returns (uint8) {
        return _initialized;
    }

    /**
     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.
     */
    function _isInitializing() internal view returns (bool) {
        return _initializing;
    }
}

// File: @openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol


// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)

pragma solidity ^0.8.2;






/**
 * @dev This abstract contract provides getters and event emitting update functions for
 * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.
 *
 * _Available since v4.1._
 *
 * @custom:oz-upgrades-unsafe-allow delegatecall
 */
abstract contract ERC1967UpgradeUpgradeable is Initializable {
    function __ERC1967Upgrade_init() internal onlyInitializing {
    }

    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {
    }
    // This is the keccak-256 hash of "eip1967.proxy.rollback" subtracted by 1
    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;

    /**
     * @dev Storage slot with the address of the current implementation.
     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is
     * validated in the constructor.
     */
    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    /**
     * @dev Emitted when the implementation is upgraded.
     */
    event Upgraded(address indexed implementation);

    /**
     * @dev Returns the current implementation address.
     */
    function _getImplementation() internal view returns (address) {
        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;
    }

    /**
     * @dev Stores a new address in the EIP1967 implementation slot.
     */
    function _setImplementation(address newImplementation) private {
        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");
        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
    }

    /**
     * @dev Perform implementation upgrade
     *
     * Emits an {Upgraded} event.
     */
    function _upgradeTo(address newImplementation) internal {
        _setImplementation(newImplementation);
        emit Upgraded(newImplementation);
    }

    /**
     * @dev Perform implementation upgrade with additional setup call.
     *
     * Emits an {Upgraded} event.
     */
    function _upgradeToAndCall(
        address newImplementation,
        bytes memory data,
        bool forceCall
    ) internal {
        _upgradeTo(newImplementation);
        if (data.length > 0 || forceCall) {
            _functionDelegateCall(newImplementation, data);
        }
    }

    /**
     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.
     *
     * Emits an {Upgraded} event.
     */
    function _upgradeToAndCallUUPS(
        address newImplementation,
        bytes memory data,
        bool forceCall
    ) internal {
        // Upgrades from old implementations will perform a rollback test. This test requires the new
        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing
        // this special case will break upgrade paths from old UUPS implementation to new ones.
        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {
            _setImplementation(newImplementation);
        } else {
            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {
                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");
            } catch {
                revert("ERC1967Upgrade: new implementation is not UUPS");
            }
            _upgradeToAndCall(newImplementation, data, forceCall);
        }
    }

    /**
     * @dev Storage slot with the admin of the contract.
     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is
     * validated in the constructor.
     */
    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

    /**
     * @dev Emitted when the admin account has changed.
     */
    event AdminChanged(address previousAdmin, address newAdmin);

    /**
     * @dev Returns the current admin.
     */
    function _getAdmin() internal view returns (address) {
        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;
    }

    /**
     * @dev Stores a new address in the EIP1967 admin slot.
     */
    function _setAdmin(address newAdmin) private {
        require(newAdmin != address(0), "ERC1967: new admin is the zero address");
        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;
    }

    /**
     * @dev Changes the admin of the proxy.
     *
     * Emits an {AdminChanged} event.
     */
    function _changeAdmin(address newAdmin) internal {
        emit AdminChanged(_getAdmin(), newAdmin);
        _setAdmin(newAdmin);
    }

    /**
     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.
     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.
     */
    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;

    /**
     * @dev Emitted when the beacon is upgraded.
     */
    event BeaconUpgraded(address indexed beacon);

    /**
     * @dev Returns the current beacon.
     */
    function _getBeacon() internal view returns (address) {
        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;
    }

    /**
     * @dev Stores a new beacon in the EIP1967 beacon slot.
     */
    function _setBeacon(address newBeacon) private {
        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");
        require(
            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),
            "ERC1967: beacon implementation is not a contract"
        );
        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;
    }

    /**
     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does
     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).
     *
     * Emits a {BeaconUpgraded} event.
     */
    function _upgradeBeaconToAndCall(
        address newBeacon,
        bytes memory data,
        bool forceCall
    ) internal {
        _setBeacon(newBeacon);
        emit BeaconUpgraded(newBeacon);
        if (data.length > 0 || forceCall) {
            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);
        }
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {
        require(AddressUpgradeable.isContract(target), "Address: delegate call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return AddressUpgradeable.verifyCallResult(success, returndata, "Address: low-level delegate call failed");
    }

    /**
     * @dev This empty reserved space is put in place to allow future versions to add new
     * variables without shifting down storage in the inheritance chain.
     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
     */
    uint256[50] private __gap;
}

// File: @openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol


// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/UUPSUpgradeable.sol)

pragma solidity ^0.8.0;




/**
 * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an
 * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.
 *
 * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is
 * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing
 * `UUPSUpgradeable` with a custom implementation of upgrades.
 *
 * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.
 *
 * _Available since v4.1._
 */
abstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {
    function __UUPSUpgradeable_init() internal onlyInitializing {
    }

    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {
    }
    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment
    address private immutable __self = address(this);

    /**
     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is
     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case
     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a
     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to
     * fail.
     */
    modifier onlyProxy() {
        require(address(this) != __self, "Function must be called through delegatecall");
        require(_getImplementation() == __self, "Function must be called through active proxy");
        _;
    }

    /**
     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be
     * callable on the implementing contract but not through proxies.
     */
    modifier notDelegated() {
        require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");
        _;
    }

    /**
     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the
     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.
     *
     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks
     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this
     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.
     */
    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {
        return _IMPLEMENTATION_SLOT;
    }

    /**
     * @dev Upgrade the implementation of the proxy to `newImplementation`.
     *
     * Calls {_authorizeUpgrade}.
     *
     * Emits an {Upgraded} event.
     */
    function upgradeTo(address newImplementation) external virtual onlyProxy {
        _authorizeUpgrade(newImplementation);
        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);
    }

    /**
     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call
     * encoded in `data`.
     *
     * Calls {_authorizeUpgrade}.
     *
     * Emits an {Upgraded} event.
     */
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {
        _authorizeUpgrade(newImplementation);
        _upgradeToAndCallUUPS(newImplementation, data, true);
    }

    /**
     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by
     * {upgradeTo} and {upgradeToAndCall}.
     *
     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.
     *
     * ```solidity
     * function _authorizeUpgrade(address) internal override onlyOwner {}
     * ```
     */
    function _authorizeUpgrade(address newImplementation) internal virtual;

    /**
     * @dev This empty reserved space is put in place to allow future versions to add new
     * variables without shifting down storage in the inheritance chain.
     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
     */
    uint256[50] private __gap;
}

// File: contracts/NameableUpgradeable.sol



pragma solidity ^0.8.17;


contract NameableUpgradeable is Initializable {

    // VARIABLES //

    /// @notice Uint256 for bio change price in $PNUT
	uint256 public bioChangePrice;
	
    /// @notice Uint256 for name change price in $PNUT.
    uint256 public nameChangePrice;

    /// @notice Mapping for bio associated with a tokenId.
	mapping(uint256 => string) internal bio;

	/// @notice Mapping if certain name string has already been reserved
	mapping(string => bool) internal _nameReserved;

	/// @notice Mapping for name associated with a tokenId.
	mapping(uint256 => string) internal _tokenName;

    // INTERNAL FUNCTIONS //

    /// @notice Internal function called when smart contract is initialized.
    function __Nameable_init() internal onlyInitializing {}

    /// @notice Internal function called when smart contract is initialized.
    function __Nameable_init_unchained() internal onlyInitializing {}

	/// @notice Internal function called which reserves the name if isReserve is set to true, de-reserves if set to false.
	function toggleReserveName(string memory str, bool isReserve) internal {
		_nameReserved[toLower(str)] = isReserve;
	}

    // PUBLIC FUNCTIONS //

    /// @notice Function called when changing token name.
	function changeName(uint256 tokenId, string memory newName) public virtual {
		// If already named, dereserve old name
		if (bytes(_tokenName[tokenId]).length > 0) {
			toggleReserveName(_tokenName[tokenId], false);
		}
        toggleReserveName(newName, true);
		_tokenName[tokenId] = newName;
	}

    /// @notice Function called when changing token bio.
	function changeBio(uint256 _tokenId, string memory _bio) public virtual {
		bio[_tokenId] = _bio;
	}

    // GETTER FUNCTIONS, READ CONTRACT FUNCTIONS //

	/// @notice Function returns bio of the NFT tokenId.
	function tokenBio(uint256 tokenId) public view returns (string memory) {
		return bio[tokenId];
	}

	/// @notice Function returns name of the NFT tokenId.
	function tokenName(uint256 tokenId) public view returns (string memory) {
		return _tokenName[tokenId];
	}

	/// @notice Function returns true or false if a name has been reserved or not.
	function isNameReserved(string memory nameString) public view returns (bool) {
		return _nameReserved[toLower(nameString)];
	}

    /// @notice Function validates name and returns true or false.
	function validateName(string memory str) internal pure returns (bool) {
		bytes memory b = bytes(str);
		if (b.length < 1) {return false;}
		if (b.length > 25) {return false;} // Cannot be longer than 25 characters
		if (b[0] == 0x20) {return false;} // Leading space
		if (b[b.length - 1] == 0x20) {return false;} // Trailing space

		bytes1 lastChar = b[0];

		for (uint i; i < b.length; i++) {
			bytes1 char = b[i];

			if (char == 0x20 && lastChar == 0x20) {return false;} // Cannot contain continous spaces

			if (!(char >= 0x30 && char <= 0x39) && //9-0
				!(char >= 0x41 && char <= 0x5A) && //A-Z
				!(char >= 0x61 && char <= 0x7A) && //a-z
				!(char == 0x20) //space
			   ) {
			   return false;
            }

			lastChar = char;
		}

		return true;
	}

	 /// @notice Function converts the string to lowercase.
	function toLower(string memory str) internal pure returns (string memory){
		bytes memory bStr = bytes(str);
		bytes memory bLower = new bytes(bStr.length);
		for (uint i = 0; i < bStr.length; i++) {
			// Uppercase character
			if ((uint8(bStr[i]) >= 65) && (uint8(bStr[i]) <= 90)) {
				bLower[i] = bytes1(uint8(bStr[i]) + 32);
			} else {
				bLower[i] = bStr[i];
			}
		}
		return string(bLower);
	}

    /**
     * @dev This empty reserved space is put in place to allow future versions to add new
     * variables without shifting down storage in the inheritance chain.
     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
     */
    uint256[45] private __gap;
}
// File: operator-filter-registry/src/upgradeable/OperatorFiltererUpgradeable.sol


pragma solidity ^0.8.13;



/**
 * @title  OperatorFiltererUpgradeable
 * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another
 *         registrant's entries in the OperatorFilterRegistry when the init function is called.
 * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:
 *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.
 *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.
 */
abstract contract OperatorFiltererUpgradeable is Initializable {
    /// @notice Emitted when an operator is not allowed.
    error OperatorNotAllowed(address operator);

    IOperatorFilterRegistry constant OPERATOR_FILTER_REGISTRY =
        IOperatorFilterRegistry(0x000000000000AAeB6D7670E522A718067333cd4E);

    /// @dev The upgradeable initialize function that should be called when the contract is being upgraded.
    function __OperatorFilterer_init(address subscriptionOrRegistrantToCopy, bool subscribe)
        internal
        onlyInitializing
    {
        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier
        // will not revert, but the contract will need to be registered with the registry once it is deployed in
        // order for the modifier to filter addresses.
        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {
            if (!OPERATOR_FILTER_REGISTRY.isRegistered(address(this))) {
                if (subscribe) {
                    OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);
                } else {
                    if (subscriptionOrRegistrantToCopy != address(0)) {
                        OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);
                    } else {
                        OPERATOR_FILTER_REGISTRY.register(address(this));
                    }
                }
            }
        }
    }

    /**
     * @dev A helper modifier to check if the operator is allowed.
     */
    modifier onlyAllowedOperator(address from) virtual {
        // Allow spending tokens from addresses with balance
        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred
        // from an EOA.
        if (from != msg.sender) {
            _checkFilterOperator(msg.sender);
        }
        _;
    }

    /**
     * @dev A helper modifier to check if the operator approval is allowed.
     */
    modifier onlyAllowedOperatorApproval(address operator) virtual {
        _checkFilterOperator(operator);
        _;
    }

    /**
     * @dev A helper function to check if the operator is allowed.
     */
    function _checkFilterOperator(address operator) internal view virtual {
        // Check registry code length to facilitate testing in environments without a deployed registry.
        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {
            // under normal circumstances, this function will revert rather than return false, but inheriting or
            // upgraded contracts may specify their own OperatorFilterRegistry implementations, which may behave
            // differently
            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {
                revert OperatorNotAllowed(operator);
            }
        }
    }
}

// File: operator-filter-registry/src/upgradeable/DefaultOperatorFiltererUpgradeable.sol


pragma solidity ^0.8.13;



/**
 * @title  DefaultOperatorFiltererUpgradeable
 * @notice Inherits from OperatorFiltererUpgradeable and automatically subscribes to the default OpenSea subscription
 *         when the init function is called.
 */
abstract contract DefaultOperatorFiltererUpgradeable is OperatorFiltererUpgradeable {
    /// @dev The upgradeable initialize function that should be called when the contract is being deployed.
    function __DefaultOperatorFilterer_init() internal onlyInitializing {
        OperatorFiltererUpgradeable.__OperatorFilterer_init(CANONICAL_CORI_SUBSCRIPTION, true);
    }
}

// File: @openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol


// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)

pragma solidity ^0.8.0;



/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 *
 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 */
abstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {
    function __ERC165_init() internal onlyInitializing {
    }

    function __ERC165_init_unchained() internal onlyInitializing {
    }
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165Upgradeable).interfaceId;
    }

    /**
     * @dev This empty reserved space is put in place to allow future versions to add new
     * variables without shifting down storage in the inheritance chain.
     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
     */
    uint256[50] private __gap;
}

// File: @openzeppelin/contracts-upgradeable/token/common/ERC2981Upgradeable.sol


// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)

pragma solidity ^0.8.0;




/**
 * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.
 *
 * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for
 * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.
 *
 * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the
 * fee is specified in basis points by default.
 *
 * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See
 * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to
 * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.
 *
 * _Available since v4.5._
 */
abstract contract ERC2981Upgradeable is Initializable, IERC2981Upgradeable, ERC165Upgradeable {
    function __ERC2981_init() internal onlyInitializing {
    }

    function __ERC2981_init_unchained() internal onlyInitializing {
    }
    struct RoyaltyInfo {
        address receiver;
        uint96 royaltyFraction;
    }

    RoyaltyInfo private _defaultRoyaltyInfo;
    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC165Upgradeable) returns (bool) {
        return interfaceId == type(IERC2981Upgradeable).interfaceId || super.supportsInterface(interfaceId);
    }

    /**
     * @inheritdoc IERC2981Upgradeable
     */
    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {
        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];

        if (royalty.receiver == address(0)) {
            royalty = _defaultRoyaltyInfo;
        }

        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();

        return (royalty.receiver, royaltyAmount);
    }

    /**
     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a
     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an
     * override.
     */
    function _feeDenominator() internal pure virtual returns (uint96) {
        return 10000;
    }

    /**
     * @dev Sets the royalty information that all ids in this contract will default to.
     *
     * Requirements:
     *
     * - `receiver` cannot be the zero address.
     * - `feeNumerator` cannot be greater than the fee denominator.
     */
    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {
        require(feeNumerator <= _feeDenominator(), "ERC2981: royalty fee will exceed salePrice");
        require(receiver != address(0), "ERC2981: invalid receiver");

        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);
    }

    /**
     * @dev Removes default royalty information.
     */
    function _deleteDefaultRoyalty() internal virtual {
        delete _defaultRoyaltyInfo;
    }

    /**
     * @dev Sets the royalty information for a specific token id, overriding the global default.
     *
     * Requirements:
     *
     * - `receiver` cannot be the zero address.
     * - `feeNumerator` cannot be greater than the fee denominator.
     */
    function _setTokenRoyalty(
        uint256 tokenId,
        address receiver,
        uint96 feeNumerator
    ) internal virtual {
        require(feeNumerator <= _feeDenominator(), "ERC2981: royalty fee will exceed salePrice");
        require(receiver != address(0), "ERC2981: Invalid parameters");

        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);
    }

    /**
     * @dev Resets royalty information for the token id back to the global default.
     */
    function _resetTokenRoyalty(uint256 tokenId) internal virtual {
        delete _tokenRoyaltyInfo[tokenId];
    }

    /**
     * @dev This empty reserved space is put in place to allow future versions to add new
     * variables without shifting down storage in the inheritance chain.
     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
     */
    uint256[48] private __gap;
}

// File: @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol


// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;


/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract ContextUpgradeable is Initializable {
    function __Context_init() internal onlyInitializing {
    }

    function __Context_init_unchained() internal onlyInitializing {
    }
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }

    /**
     * @dev This empty reserved space is put in place to allow future versions to add new
     * variables without shifting down storage in the inheritance chain.
     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
     */
    uint256[50] private __gap;
}

// File: @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol


// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.0;



/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    function __Ownable_init() internal onlyInitializing {
        __Ownable_init_unchained();
    }

    function __Ownable_init_unchained() internal onlyInitializing {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }

    /**
     * @dev This empty reserved space is put in place to allow future versions to add new
     * variables without shifting down storage in the inheritance chain.
     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
     */
    uint256[49] private __gap;
}

// File: contracts/ERC721AUpgradeable.sol


// ERC721A Contracts v3.3.0
// Creator: Chiru Labs

pragma solidity ^0.8.4;








/**
 * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
 * the Metadata extension. Built to optimize for lower gas during batch mints.
 *
 * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).
 *
 * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.
 *
 * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).
 */
contract ERC721AUpgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721AUpgradeable {
    using AddressUpgradeable for address;
    using StringsUpgradeable for uint256;

    // The tokenId of the next token to be minted.
    uint256 internal _currentIndex;

    // The number of tokens burned.
    uint256 internal _burnCounter;

    // Token name
    string private _name;

    // Token symbol
    string private _symbol;

    // Mapping from token ID to ownership details
    // An empty struct value does not necessarily mean the token is unowned. See _ownershipOf implementation for details.
    mapping(uint256 => TokenOwnership) internal _ownerships;

    // Mapping owner address to address data
    mapping(address => AddressData) private _addressData;

    // Mapping from token ID to approved address
    mapping(uint256 => address) private _tokenApprovals;

    // Mapping from owner to operator approvals
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    function __ERC721A_init(string memory name_, string memory symbol_) internal onlyInitializing {
        __ERC721A_init_unchained(name_, symbol_);
    }

    function __ERC721A_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {
        _name = name_;
        _symbol = symbol_;
        _currentIndex = _startTokenId();
    }

    /**
     * To change the starting tokenId, please override this function.
     */
    function _startTokenId() internal view virtual returns (uint256) {
        return 0;
    }

    /**
     * @dev Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.
     */
    function totalSupply() public view override returns (uint256) {
        // Counter underflow is impossible as _burnCounter cannot be incremented
        // more than _currentIndex - _startTokenId() times
        unchecked {
            return _currentIndex - _burnCounter - _startTokenId();
        }
    }

    /**
     * Returns the total amount of tokens minted in the contract.
     */
    function _totalMinted() internal view returns (uint256) {
        // Counter underflow is impossible as _currentIndex does not decrement,
        // and it is initialized to _startTokenId()
        unchecked {
            return _currentIndex - _startTokenId();
        }
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {
        return
            interfaceId == type(IERC721Upgradeable).interfaceId ||
            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @dev See {IERC721-balanceOf}.
     */
    function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }

    /**
     * Returns the number of tokens minted by `owner`.
     */
    function _numberMinted(address owner) internal view returns (uint256) {
        return uint256(_addressData[owner].numberMinted);
    }

    /**
     * Returns the number of tokens burned by or on behalf of `owner`.
     */
    function _numberBurned(address owner) internal view returns (uint256) {
        return uint256(_addressData[owner].numberBurned);
    }

    /**
     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).
     */
    function _getAux(address owner) internal view returns (uint64) {
        return _addressData[owner].aux;
    }

    /**
     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).
     * If there are multiple variables, please pack them into a uint64.
     */
    function _setAux(address owner, uint64 aux) internal {
        _addressData[owner].aux = aux;
    }

    /**
     * Gas spent here starts off proportional to the maximum mint batch size.
     * It gradually moves to O(1) as tokens get transferred around in the collection over time.
     */
    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {
        uint256 curr = tokenId;

        unchecked {
            if (_startTokenId() <= curr) if (curr < _currentIndex) {
                TokenOwnership memory ownership = _ownerships[curr];
                if (!ownership.burned) {
                    if (ownership.addr != address(0)) {
                        return ownership;
                    }
                    // Invariant:
                    // There will always be an ownership that has an address and is not burned
                    // before an ownership that does not have an address and is not burned.
                    // Hence, curr will not underflow.
                    while (true) {
                        curr--;
                        ownership = _ownerships[curr];
                        if (ownership.addr != address(0)) {
                            return ownership;
                        }
                    }
                }
            }
        }
        revert OwnerQueryForNonexistentToken();
    }

    /**
     * @dev See {IERC721-ownerOf}.
     */
    function ownerOf(uint256 tokenId) public view override returns (address) {
        return _ownershipOf(tokenId).addr;
    }

    /**
     * @dev See {IERC721Metadata-name}.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev See {IERC721Metadata-symbol}.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();

        string memory baseURI = _baseURI();
        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : '';
    }

    /**
     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
     * by default, can be overriden in child contracts.
     */
    function _baseURI() internal view virtual returns (string memory) {
        return '';
    }

    /**
     * @dev See {IERC721-approve}.
     */
    function approve(address to, uint256 tokenId) public virtual override {
        address owner = ERC721AUpgradeable.ownerOf(tokenId);
        if (to == owner) revert ApprovalToCurrentOwner();

        if (_msgSender() != owner) if(!isApprovedForAll(owner, _msgSender())) {
            revert ApprovalCallerNotOwnerNorApproved();
        }

        _approve(to, tokenId, owner);
    }

    /**
     * @dev See {IERC721-getApproved}.
     */
    function getApproved(uint256 tokenId) public view override returns (address) {
        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();

        return _tokenApprovals[tokenId];
    }

    /**
     * @dev See {IERC721-setApprovalForAll}.
     */
    function setApprovalForAll(address operator, bool approved) public virtual override {
        if (operator == _msgSender()) revert ApproveToCaller();

        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }

    /**
     * @dev See {IERC721-isApprovedForAll}.
     */
    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    /**
     * @dev See {IERC721-transferFrom}.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        _transfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        safeTransferFrom(from, to, tokenId, '');
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) public virtual override {
        _transfer(from, to, tokenId);
        if (to.isContract()) if(!_checkContractOnERC721Received(from, to, tokenId, _data)) {
            revert TransferToNonERC721ReceiverImplementer();
        }
    }

    /**
     * @dev Returns whether `tokenId` exists.
     *
     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
     *
     * Tokens start existing when they are minted (`_mint`),
     */
    function _exists(uint256 tokenId) internal view returns (bool) {
        return _startTokenId() <= tokenId && tokenId < _currentIndex && !_ownerships[tokenId].burned;
    }

    /**
     * @dev Equivalent to `_safeMint(to, quantity, '')`.
     */
    function _safeMint(address to, uint256 quantity) internal {
        _safeMint(to, quantity, '');
    }

    /**
     * @dev Safely mints `quantity` tokens and transfers them to `to`.
     *
     * Requirements:
     *
     * - If `to` refers to a smart contract, it must implement
     *   {IERC721Receiver-onERC721Received}, which is called for each safe transfer.
     * - `quantity` must be greater than 0.
     *
     * Emits a {Transfer} event.
     */
    function _safeMint(
        address to,
        uint256 quantity,
        bytes memory _data
    ) internal {
        uint256 startTokenId = _currentIndex;
        if (to == address(0)) revert MintToZeroAddress();
        if (quantity == 0) revert MintZeroQuantity();

        _beforeTokenTransfers(address(0), to, startTokenId, quantity);

        // Overflows are incredibly unrealistic.
        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1
        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1
        unchecked {
            _addressData[to].balance += uint64(quantity);
            _addressData[to].numberMinted += uint64(quantity);

            _ownerships[startTokenId].addr = to;
            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);

            uint256 updatedIndex = startTokenId;
            uint256 end = updatedIndex + quantity;

            if (to.isContract()) {
                do {
                    emit Transfer(address(0), to, updatedIndex);
                    if (!_checkContractOnERC721Received(address(0), to, updatedIndex++, _data)) {
                        revert TransferToNonERC721ReceiverImplementer();
                    }
                } while (updatedIndex < end);
                // Reentrancy protection
                if (_currentIndex != startTokenId) revert();
            } else {
                do {
                    emit Transfer(address(0), to, updatedIndex++);
                } while (updatedIndex < end);
            }
            _currentIndex = updatedIndex;
        }
        _afterTokenTransfers(address(0), to, startTokenId, quantity);
    }

    /**
     * @dev Mints `quantity` tokens and transfers them to `to`.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `quantity` must be greater than 0.
     *
     * Emits a {Transfer} event.
     */
    function _mint(address to, uint256 quantity) internal {
        uint256 startTokenId = _currentIndex;
        if (to == address(0)) revert MintToZeroAddress();
        if (quantity == 0) revert MintZeroQuantity();

        _beforeTokenTransfers(address(0), to, startTokenId, quantity);

        // Overflows are incredibly unrealistic.
        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1
        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1
        unchecked {
            _addressData[to].balance += uint64(quantity);
            _addressData[to].numberMinted += uint64(quantity);

            _ownerships[startTokenId].addr = to;
            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);

            uint256 updatedIndex = startTokenId;
            uint256 end = updatedIndex + quantity;

            do {
                emit Transfer(address(0), to, updatedIndex++);
            } while (updatedIndex < end);

            _currentIndex = updatedIndex;
        }
        _afterTokenTransfers(address(0), to, startTokenId, quantity);
    }

    /**
     * @dev Transfers `tokenId` from `from` to `to`.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     *
     * Emits a {Transfer} event.
     */
    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) private {
        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);

        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();

        bool isApprovedOrOwner = (_msgSender() == from ||
            isApprovedForAll(from, _msgSender()) ||
            getApproved(tokenId) == _msgSender());

        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();
        if (to == address(0)) revert TransferToZeroAddress();

        _beforeTokenTransfers(from, to, tokenId, 1);

        // Clear approvals from the previous owner
        _approve(address(0), tokenId, from);

        // Underflow of the sender's balance is impossible because we check for
        // ownership above and the recipient's balance can't realistically overflow.
        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.
        unchecked {
            _addressData[from].balance -= 1;
            _addressData[to].balance += 1;

            TokenOwnership storage currSlot = _ownerships[tokenId];
            currSlot.addr = to;
            currSlot.startTimestamp = uint64(block.timestamp);

            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.
            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.
            uint256 nextTokenId = tokenId + 1;
            TokenOwnership storage nextSlot = _ownerships[nextTokenId];
            if (nextSlot.addr == address(0)) {
                // This will suffice for checking _exists(nextTokenId),
                // as a burned slot cannot contain the zero address.
                if (nextTokenId != _currentIndex) {
                    nextSlot.addr = from;
                    nextSlot.startTimestamp = prevOwnership.startTimestamp;
                }
            }
        }

        emit Transfer(from, to, tokenId);
        _afterTokenTransfers(from, to, tokenId, 1);
    }

    /**
     * @dev Equivalent to `_burn(tokenId, false)`.
     */
    function _burn(uint256 tokenId) internal virtual {
        _burn(tokenId, false);
    }

    /**
     * @dev Destroys `tokenId`.
     * The approval is cleared when the token is burned.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     *
     * Emits a {Transfer} event.
     */
    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {
        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);

        address from = prevOwnership.addr;

        if (approvalCheck) {
            bool isApprovedOrOwner = (_msgSender() == from ||
                isApprovedForAll(from, _msgSender()) ||
                getApproved(tokenId) == _msgSender());

            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();
        }

        _beforeTokenTransfers(from, address(0), tokenId, 1);

        // Clear approvals from the previous owner
        _approve(address(0), tokenId, from);

        // Underflow of the sender's balance is impossible because we check for
        // ownership above and the recipient's balance can't realistically overflow.
        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.
        unchecked {
            AddressData storage addressData = _addressData[from];
            addressData.balance -= 1;
            addressData.numberBurned += 1;

            // Keep track of who burned the token, and the timestamp of burning.
            TokenOwnership storage currSlot = _ownerships[tokenId];
            currSlot.addr = from;
            currSlot.startTimestamp = uint64(block.timestamp);
            currSlot.burned = true;

            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.
            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.
            uint256 nextTokenId = tokenId + 1;
            TokenOwnership storage nextSlot = _ownerships[nextTokenId];
            if (nextSlot.addr == address(0)) {
                // This will suffice for checking _exists(nextTokenId),
                // as a burned slot cannot contain the zero address.
                if (nextTokenId != _currentIndex) {
                    nextSlot.addr = from;
                    nextSlot.startTimestamp = prevOwnership.startTimestamp;
                }
            }
        }

        emit Transfer(from, address(0), tokenId);
        _afterTokenTransfers(from, address(0), tokenId, 1);

        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.
        unchecked {
            _burnCounter++;
        }
    }

    /**
     * @dev Approve `to` to operate on `tokenId`
     *
     * Emits a {Approval} event.
     */
    function _approve(
        address to,
        uint256 tokenId,
        address owner
    ) private {
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    /**
     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.
     *
     * @param from address representing the previous owner of the given token ID
     * @param to target address that will receive the tokens
     * @param tokenId uint256 ID of the token to be transferred
     * @param _data bytes optional data to send along with the call
     * @return bool whether the call correctly returned the expected magic value
     */
    function _checkContractOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) private returns (bool) {
        try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
            return retval == IERC721ReceiverUpgradeable(to).onERC721Received.selector;
        } catch (bytes memory reason) {
            if (reason.length == 0) {
                revert TransferToNonERC721ReceiverImplementer();
            } else {
                assembly {
                    revert(add(32, reason), mload(reason))
                }
            }
        }
    }

    /**
     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.
     * And also called before burning one token.
     *
     * startTokenId - the first token id to be transferred
     * quantity - the amount to be transferred
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be
     * transferred to `to`.
     * - When `from` is zero, `tokenId` will be minted for `to`.
     * - When `to` is zero, `tokenId` will be burned by `from`.
     * - `from` and `to` are never both zero.
     */
    function _beforeTokenTransfers(
        address from,
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal virtual {}

    /**
     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes
     * minting.
     * And also called after one token has been burned.
     *
     * startTokenId - the first token id to be transferred
     * quantity - the amount to be transferred
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been
     * transferred to `to`.
     * - When `from` is zero, `tokenId` has been minted for `to`.
     * - When `to` is zero, `tokenId` has been burned by `from`.
     * - `from` and `to` are never both zero.
     */
    function _afterTokenTransfers(
        address from,
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal virtual {}

    /**
     * @dev This empty reserved space is put in place to allow future versions to add new
     * variables without shifting down storage in the inheritance chain.
     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
     */
    uint256[42] private __gap;
}


// File: contracts/LuckyElephantClub.sol

pragma solidity ^0.8.17;

contract LuckyElephantClub is Initializable, ERC721AUpgradeable, OwnableUpgradeable, DefaultOperatorFiltererUpgradeable, ERC2981Upgradeable, NameableUpgradeable, UUPSUpgradeable {

    using StringsUpgradeable for uint256;

    // VARIABLES //

    /// @notice PNBB erc20 token contract address.
    IPNBB public PNBB;

    /// @notice PNUT erc20 token contract address.
    IPNUT public PNUT;

    /// @notice YieldHub contract address.
    IYieldHub public YieldHub;

    /// @notice Address of community wallet.
    address public communityWallet;

    /// @notice Boolean to reveal or unreveal.
    bool public revealed;

    /// @notice Bytes32 for merkle root hash.
    bytes32 public merkleRoot;

    /**
     * @notice Mapping for total number of NFTs minted by an address for a sale mode.
     * Sale modes:
     * 1 = Genesis Mint,
     * 2 = OGs Mint, 
     * 3 = LuckyList Mint,
     * 4 = Public Minting,
     * 5 = Amalgamation / Baby .
     */
    mapping(uint256 => mapping(address => uint256)) public addressMinted;

    /// @notice Mapping for balance of genesis associated with an address.
    mapping(address => uint256) internal _balanceGenesis;

    /**
     * @notice Mapping for whether minting is enabled for a sale mode,
     * true if enabled, false if disabled.
     * Sale modes:
     * 1 = Genesis Mint,
     * 2 = OGs Mint, 
     * 3 = LuckyList Mint,
     * 4 = Public Minting,
     * 5 = Amalgamation / Baby .
     */
    mapping(uint256 => bool) public _mintingEnabled;

    /**
     * @notice Mapping for max supply for a sale mode,
     * Sale modes:
     * 1 = Genesis Mint,
     * 2 = OGs Mint, 
     * 3 = LuckyList Mint,
     * 4 = Public Minting,
     * 5 = Amalgamation / Baby .
     */
    mapping(uint256 => uint256) public _maxSupply;

    /**
     * @notice Mapping for max mint per address for a sale mode,
     * Sale modes:
     * 1 = Genesis Mint,
     * 2 = OGs Mint, 
     * 3 = LuckyList Mint,
     * 4 = Public Minting,
     * 5 = Amalgamation / Baby .
     */
    mapping(uint256 => uint256) public _maxMintPerAddress;

    /**
     * @notice Mapping for total minted for a sale mode,
     * Sale modes:
     * 1 = Genesis Mint,
     * 2 = OGs Mint, 
     * 3 = LuckyList Mint,
     * 4 = Public Minting,
     * 5 = Amalgamation / Baby .
     */
    mapping(uint256 => uint256) public _minted;

    /**
     * @notice Mapping for minting price for a sale mode,
     * Sale modes:
     * 1 = Genesis Mint,
     * 2 = OGs Mint, 
     * 3 = LuckyList Mint,
     * 4 = Public Minting,
     * 5 = Amalgamation / Baby .
     */
    mapping(uint256 => uint256) public _price;
    
    /// @notice Mapping for DNA.
	mapping(string => Baby) public DNA;

    /// @notice String for base token URI prefix.
    string public baseTokenURIPrefix;

    /// @notice String for base token URI suffix.
    string public baseTokenURISuffix;

    /// @notice String for not revealed URI.
    string public notRevealedURI;

    /// @notice Struct for storing details of baby.
    struct Baby {
        uint256 parent1;
        uint256 parent2;
        string dna;
    }

    /// @notice Uint256 for amalgamation price in $PNUT.
    uint256 public amalgamatePrice;

    /// @notice Uint256 for max supply of the entire collection.
    uint256 public maxSupply;

    /**
     * @notice Uint256 for sale mode.
     * Sale modes:
     * 1 = Genesis Mint,
     * 2 = OGs Mint, 
     * 3 = LuckyList Mint,
     * 4 = Public Minting,
     * 5 = Amalgamation / Baby .
     */
    uint256 public saleMode;

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() { 
        _disableInitializers();
    }

    // INITIALIZATION //

    /// @notice Function to initialize the smart contract. 
    function initialize() initializer public {
        __ERC721A_init("Lucky Elephant Club", "LEC");
        __Ownable_init();
        __DefaultOperatorFilterer_init();
        __ERC2981_init();
        __Nameable_init();
        __UUPSUpgradeable_init();

        baseTokenURISuffix = ".json";

        saleMode = 1;
    }

    // MODIFIERS //

    /// @notice Modifier for amalgamation compliances.
    modifier amalgamateCompliance(uint256 _parent1, uint256 _parent2) {
        require(saleMode == 5, "Amalgamating not active");
        require(_minted[saleMode] + 1 <= _maxSupply[saleMode], "No more babies can be amalgamated");
        require(_mintingEnabled[saleMode] == true, "Minting not enabled");
        require(ownerOf(_parent1) == msg.sender, "You don't own this token");
        if (_parent2 < maxSupply - _maxSupply[5]) {
            require(ownerOf(_parent2) == msg.sender, "You don't own this token");
        }
        _;
    }

    /// @notice Modifier for mint compliances.
    modifier mintCompliance(address _to, uint256 _mintAmount) {
        require(_mintAmount + addressMinted[saleMode][_to] <= _maxMintPerAddress[saleMode], "You can't mint more for the saleMode");
        require(msg.value >= _mintAmount * _price[saleMode], "Insufficient Fund");
        require(_minted[saleMode] + _mintAmount <= _maxSupply[saleMode], "No more NFTs to mint for the saleMode");
        require(_mintingEnabled[saleMode] == true, "Minting not enabled");
        _;
    }

    // PUBLIC FUNCTIONS, WRITE CONTRACT FUNCTIONS //

    /**
     * @notice Public function.
     * Function that allows the caller to amalgamate a NFT using $PNUT to create a new NFT.
     * Requires saleMode value to be 5.
     * Requires minting for saleMode 5 to be enabled.
     * _singleParent: tokenId of the single parent NFT.
     */
    function amalgamateWithERC20(uint256 _singleParent) public amalgamateCompliance(_singleParent, maxSupply)  {
        string memory pair = getDNAFromPair(_singleParent, maxSupply);
        require(!compareDNA(DNA[pair].dna, pair), "DNA exist, try other combination");
		require(PNUT.balanceOf(msg.sender) >= amalgamatePrice, "You don't have enough $PNUT");
        _safeMint(msg.sender, 1);
        addressMinted[saleMode][msg.sender]++;
        _minted[saleMode]++;
        DNA[pair] = Baby(_singleParent, maxSupply, pair);
        PNUT.burnByLEC(msg.sender, amalgamatePrice);
    }

    /**
     * @notice Public function.
     * Function that allows a caller to amalgamate two NFTs to create a new NFT.
     * Requires saleMode value to be 5.
     * Requires minting for saleMode 5 to be enabled.
     * _parent1: tokenId of the first parent NFT.
     * _parent2: tokenId of the second parent NFT.
     */
    function amalgamateWithParents(uint256 _parent1, uint256 _parent2) public amalgamateCompliance(_parent1, _parent2) {
        string memory pair = getDNAFromPair(_parent1, _parent2);
        require(!compareDNA(DNA[pair].dna, pair), "DNA exist, try other combination");
        _safeMint(msg.sender, 1);
        addressMinted[saleMode][msg.sender]++;
        _minted[saleMode]++;
        DNA[pair] = Baby(_parent1, _parent2, pair);
    }

    /**
     * @notice Public function.
     * Function that allows the owner of an NFT to update the NFT's bio using $PNUT.
     * _tokenId: tokenId of the NFT to update.
     * _newBio: New bio string for the NFT.
     */
    function changeBio(uint256 _tokenId, string memory _newBio) public override {
		address owner = ownerOf(_tokenId);
		require(_msgSender() == owner, "ERC721: Caller are not the token owner");
		require(PNUT.balanceOf(msg.sender) >= bioChangePrice, "You don't have enough $PNUT");
        PNUT.burnByLEC(msg.sender, bioChangePrice);
		super.changeBio(_tokenId, _newBio);
    }

    /**
     * @notice Public function.
     * Function that allows the owner of an NFT to update the NFT's name using $PNUT.
     * _tokenId: tokenId of the NFT to update.
     * _newBio: New bio string for the NFT.
     */
    function changeName(uint256 _tokenId, string memory _newName) public override {
		address owner = ownerOf(_tokenId);
		require(_msgSender() == owner, "ERC721: Caller are not the token owner");
		require(PNUT.balanceOf(msg.sender) >= nameChangePrice, "You don't have enough $PNUT");
		require(validateName(_newName) == true, "New name is not valid");
		require(keccak256(bytes(_newName)) != keccak256(bytes(tokenName(_tokenId))), "New name is same as the current one");
		require(isNameReserved(_newName) == false, "New name is not available");
        PNUT.burnByLEC(msg.sender, nameChangePrice);
		super.changeName(_tokenId, _newName);
	}

    /**
     * @notice Public function.
     * Function mints a specified amount of tokens to a given address.
     * Requires saleMode value to be 4.
     * Requires minting for saleMode 4 to be enabled.
     * Requires sufficient ETH to execute.
     * _recipient: The address of the recipient.
     * _mintAmount: The amount of tokens to mint.
     */
    function publicMint(address _recipient, uint256 _mintAmount) public payable mintCompliance(_recipient, _mintAmount) {
        require(saleMode == 4, "Incorrect sale mode");
        _safeMint(_recipient, _mintAmount);
        addressMinted[saleMode][_recipient] += _mintAmount;
        _minted[saleMode] += _mintAmount;
    }

    /**
     * @notice Public function.
     * Function mints a specified amount of Genesis tokens to the caller using a whitelist.
     * Requires saleMode value to be 1.
     * Requires minting for saleMode 1 to be enabled.
     * Requires sufficient ETH to execute.
     * _mintAmount: The amount of tokens to mint.
     * _merkleProof: The merkle proof array of the caller being on the whitelist.
     */
    function whitelistMintGenesis(uint256 _mintAmount, bytes32[] calldata _merkleProof) public payable mintCompliance(msg.sender, _mintAmount) {
        require(saleMode == 1, "Incorrect sale mode");
        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
        require(MerkleProofUpgradeable.verify(_merkleProof, merkleRoot, leaf), "You are not whitelisted");
        _safeMint(msg.sender, _mintAmount);
        addressMinted[saleMode][msg.sender] += _mintAmount;
        _minted[saleMode] += _mintAmount;
    }

    /**
     * @notice Public function.
     * Function mints a specified amount of OGs tokens to the caller using a whitelist.
     * Requires saleMode value to be 2.
     * Requires minting for saleMode 2 to be enabled.
     * Requires sufficient ETH to execute.
     * _mintAmount: The amount of tokens to mint.
     * _merkleProof: The merkle proof array of the caller being on the whitelist.
     */
    function whitelistMintOGs(uint256 _mintAmount, bytes32[] calldata _merkleProof) public payable mintCompliance(msg.sender, _mintAmount) {
        require(saleMode == 2, "Incorrect sale mode");
        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
        require(MerkleProofUpgradeable.verify(_merkleProof, merkleRoot, leaf), "You are not whitelisted");
        _safeMint(msg.sender, _mintAmount);
        addressMinted[saleMode][msg.sender] += _mintAmount;
        _minted[saleMode] += _mintAmount;
    }

    /**
     * @notice Public function.
     * Function mints a specified amount of LuckyList tokens to the caller using a whitelist.
     * Requires saleMode value to be 3.
     * Requires minting for saleMode 3 to be enabled.
     * Requires sufficient ETH to execute.
     * _mintAmount: The amount of tokens to mint.
     * _merkleProof: The merkle proof array of the caller being on the whitelist.
     */
    function whitelistMintLuckyList(uint256 _mintAmount, bytes32[] calldata _merkleProof) public payable mintCompliance(msg.sender, _mintAmount) {
        require(saleMode == 3, "Incorrect sale mode");
        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
        require(MerkleProofUpgradeable.verify(_merkleProof, merkleRoot, leaf), "You are not whitelisted");
        _safeMint(msg.sender, _mintAmount);
        addressMinted[saleMode][msg.sender] += _mintAmount;
        _minted[saleMode] += _mintAmount;
    }

    // SMART CONTRACT OWNER ONLY FUNCTIONS, WRITE CONTRACT FUNCTIONS //

    /**
     * @notice Smart contract owner only function.
     * Function airdrops a specified amount of tokens to an array of addresses for the current saleMode.
     * _recipients: The array of addresses to receive the airdrop.
     * _amount: The amount of tokens to airdrop to each address.
     */
    function airdrop(address[] calldata _recipients, uint256 _amount) public onlyOwner {
        require(_minted[saleMode] + _recipients.length * _amount <= _maxSupply[saleMode], "Exceeds sale mode max supply");
        for (uint256 i = 0; i < _recipients.length; i++) {
            _safeMint(_recipients[i], _amount);
            _minted[saleMode] += _amount;
        }
    }

    /**
     * @notice Smart contract owner only function.
     * Function changes the base token URI prefix.
     * newBaseTokenURI: The new base token URI prefix.
     */
    function changeBaseTokenURIPrefix(string memory newBaseTokenURIPrefix) public onlyOwner {
        baseTokenURIPrefix = newBaseTokenURIPrefix;
    }

    /**
     * @notice Smart contract owner only function.
     * Function changes the base token URI suffix.
     * newBaseTokenURISuffix: The new base token URI suffix.
     */
    function changeBaseTokenURISuffix(string memory newBaseTokenURISuffix) public onlyOwner {
        baseTokenURISuffix = newBaseTokenURISuffix;
    }

    /**
     * @notice Smart contract owner only function.
     * Function changes or increments the current sale mode safely to the next mode.
     * Use of this function is strongly recommended to change the sale mode.
     * Sale modes:
     * 1 = Genesis Mint,
     * 2 = OGs Mint, 
     * 3 = LuckyList Mint,
     * 4 = Public Minting,
     * 5 = Amalgamation / Baby .
     */
    function changeSaleModeSafely() public onlyOwner {
        require(_maxSupply[saleMode] > 0, "Max supply of current sale mode must be greater than zero");
        require(_maxSupply[saleMode + 1] > 0, "Max supply of next sale mode must be greater than zero");
        require(_minted[saleMode] == _maxSupply[saleMode], "Minted for the current sale mode must be equal to the max supply for the sale mode");
        saleMode++;
    }

    /**
     * @notice Smart contract owner only function.
     * Function changes the sale mode.
     * Use of changeSaleModeSafely function is recommended rather than using this function.
     * _saleMode: The sale mode.
     * Sale modes:
     * 1 = Genesis Mint,
     * 2 = OGs Mint, 
     * 3 = LuckyList Mint,
     * 4 = Public Minting,
     * 5 = Amalgamation / Baby .
     */
    function changeSaleMode(uint256 _saleMode) public onlyOwner {
        saleMode = _saleMode;
    }

    /**
     * @notice Smart contract owner only function.
     * Function sets the amalgamation price required to execute the amalgamationWithERC20 function. 
     * newAmalgamatePrice: The new amalgamation price required to execute the amalgamationWithERC20 function.
     */  
    function setAmalgamatePrice(uint256 newAmalgamatePrice) public onlyOwner {
        amalgamatePrice = newAmalgamatePrice;
    }

    /** 
     * @notice Smart contract owner only function.
     * ERC2981 royalty standard implementation function.
     * It is upto the marketplace to honour this standard.
     * Function sets royalties for the entire collection for secondary sales.
     * Basis points limit is 10000, 500 basis points will mean 5% royalties on each sale.
     * To receive royalties to a payment splitter smart contract,
     * enter the payment splitter smart contract's contract address as the receiver.
     * receiver: The address of the royalty receiver.
     * basisPoints: The royalties in basis points.
     */
    function setCollectionRoyalties(address receiver, uint96 basisPoints) public onlyOwner {
        _setDefaultRoyalty(receiver, basisPoints);
    }

    /**
     * @notice Smart contract owner only function.
     * Function sets the community wallet address.
     * newAddress: The new community wallet address.
     */
    function setCommunityWallet(address newAddress) public onlyOwner {
        communityWallet = newAddress;
    }

    /**
     * @notice Smart contract owner only function.
     * Function sets the price for changing a token's name and bio.
     * newNameChangePrice: The new price for changing a token's name.
     * newBioChangePrice: The new price for changing a token's bio.
     */
    function setNameAndBioChangePrice(uint256 newNameChangePrice, uint256 newBioChangePrice) public onlyOwner {
		nameChangePrice = newNameChangePrice;
		bioChangePrice = newBioChangePrice;
	}

    /**
     * @notice Smart contract owner only function.
     * Function sets the maximum allowed supply of tokens.
     * The new maximum supply must be greater than or equal to the current total supply.
     * newMaxSupply: The new maximum allowed supply of tokens.
     */
    function setMaxSupply(uint256 newMaxSupply) public onlyOwner {
        require(newMaxSupply >= totalSupply(), "newMaxSupply must be greater than or equal to the totalSupply");
        maxSupply = newMaxSupply;
    }

    /**
     * @notice Smart contract owner only function.
     * Function sets the merkle root for the whitelist.
     * merkleHash: The new merkle root hash.
     */
    function setMerkleRoot(bytes32 merkleHash) public onlyOwner {
        merkleRoot = merkleHash;
    }

    /**
     * @notice Smart contract owner only function.
     * Function sets the URI for tokens when not revealed.
     * newNotRevealedURI: The new URI for tokens when not revealed.
     */
    function setNotRevealedURI(string memory newNotRevealedURI) public onlyOwner {
        notRevealedURI = newNotRevealedURI;
    }

    /**
     * @notice Smart contract owner only function.
     * Function sets the addresses of the PNBB and PNUT ERC20 contracts.
     * addressPNBB: The address of the PNBB ERC20 contract.
     * addressPNUT: The address of the PNUT ERC20 contract.
     * addressYieldHub: The address of the YieldHub contract.
     */
    function setPNBBAndPNUTAndYieldHub(address addressPNBB, address addressPNUT, address addressYieldHub) public onlyOwner {
        PNBB = IPNBB(addressPNBB);
        PNUT = IPNUT(addressPNUT);
        YieldHub = IYieldHub(addressYieldHub);
    }

    /**
     * @notice Smart contract owner only function.
     * Function sets the revealed status.
     * status: true to set as revealed, false to set as not revealed.
     */
    function setRevealedStatus(bool status) public onlyOwner {
        revealed = status;
    }

    /**
     * @notice Smart contract owner only function.
     * Function set the max supply and max mint per address for a sale mode.
     * _saleMode: The sale mode.
     * __maxSupply: The max supply for the sale mode.
     * __maxMintPerAddress: The max mint per address for the sale mode.
     * Sale modes:
     * 1 = Genesis Mint,
     * 2 = OGs Mint, 
     * 3 = LuckyList Mint,
     * 4 = Public Minting,
     * 5 = Amalgamation / Baby .
     */
    function setMaxMintAndSupply(uint256 _saleMode, uint256 __maxSupply, uint256 __maxMintPerAddress) public onlyOwner {
        require(__maxSupply >= _minted[_saleMode], "__maxSupply must be greater than or equal to current minted for the saleMode");
        require(__maxMintPerAddress <= __maxSupply, "__maxMintPerAddress must be smaller than or equal to __maxSupply");
        _maxSupply[_saleMode] = __maxSupply;
        _maxMintPerAddress[_saleMode] = __maxMintPerAddress;
    }

    /**
     * @notice Smart contract owner only function.
     * Function enables or disables minting for a sale mode.
     * _saleMode: The sale mode.
     * __mintingEnabled: Set to true to enable minting for the sale mode and to false to disable minting for the sale mode.
     * Sale modes:
     * 1 = Genesis Mint,
     * 2 = OGs Mint, 
     * 3 = LuckyList Mint,
     * 4 = Public Minting,
     * 5 = Amalgamation / Baby .
     */
    function setMintingEnabled(uint256 _saleMode, bool __mintingEnabled) public onlyOwner {
        _mintingEnabled[_saleMode] = __mintingEnabled;
    }

    /**
     * @notice Smart contract owner only function.
     * Function sets the price for minting a single NFT for a sale mode.
     * _saleMode: The sale mode.
     * __price: The price of a single NFT for the sale mode.
     * Sale modes:
     * 1 = Genesis Mint,
     * 2 = OGs Mint, 
     * 3 = LuckyList Mint,
     * 4 = Public Minting,
     * 5 = Amalgamation / Baby .
     */
    function setPrice(uint256 _saleMode, uint256 __price) public onlyOwner {
        _price[_saleMode] = __price;
    }

    /**
     * @notice Smart contract owner only function.
     * Functions withdraws the ETH accumulated in the smart contract to the community wallet and the smart contract owner's wallet.
     * 80% of the mint price would be transferred to the community wallet.
     */
    function withdraw() public onlyOwner {
        payable(communityWallet).transfer(address(this).balance * 8 / 10);      
        payable(msg.sender).transfer(address(this).balance);
    }

    // OVERRIDDEN PUBLIC WRITE CONTRACT FUNCTIONS: OpenSea's Royalty Filterer Implementation //

    function approve(address operator, uint256 tokenId) public override onlyAllowedOperatorApproval(operator) {
        super.approve(operator, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {
        super.safeTransferFrom(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public override onlyAllowedOperator(from) {
        super.safeTransferFrom(from, to, tokenId, data);
    }

    function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {
        super.setApprovalForAll(operator, approved);
    }

    function transferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {
        super.transferFrom(from, to, tokenId);
    }

    // GETTER FUNCTIONS, READ CONTRACT FUNCTIONS //

    /**
     * @notice Function queries and returns the genesis balance of a account.
     * account: The address of the account.
     */
    function balanceGenesis(address account) public view returns (uint256) {
        return _balanceGenesis[account];
    }

    /**
     * @notice Function queries and returns the DNA from pair of two parent NFTs.
     * parent1: The tokenId of the parent1 NFT.
     * parent2: The tokenId of the parent2 NFT.
     */
    function getDNAFromPair(uint256 parent1, uint256 parent2) public pure returns (string memory) {
        require(parent1 != parent2, "Use different parents");
        uint256 lowest = parent1 < parent2 ? parent1 : parent2;
        uint256 highest = lowest == parent1 ? parent2 : parent1;
        return string(abi.encodePacked(StringsUpgradeable.toString(lowest), ":", StringsUpgradeable.toString(highest)));
    }

    /**
     * @notice Function queries and returns true or false for whether a interface is supported or not.
     * interfaceId: The interface.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override (ERC721AUpgradeable, ERC2981Upgradeable) returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    /**
     * @notice Function queries and returns the URI for a NFT tokenId.
     * tokenId: The tokenId of the NFT.
     */
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        if (revealed == false) {
            return notRevealedURI;
        }
        return bytes(baseTokenURIPrefix).length > 0 ? string(abi.encodePacked(baseTokenURIPrefix, tokenId.toString(), baseTokenURISuffix)) : "";
    }

    /**
     * @notice Function scans and returns all the NFT tokenIds owned by an address from startTokenId till stopTokenId.
     * startTokenId: Must be equal to or greater than zero and smaller than stopTokenId.
     * stopTokenId: Must be greater than startTokenId and smaller or equal to totalSupply - 1.
     * For example, if startTokenId is 10 and stopTokenId is 80, the function will return all the NFT tokenIds owned by the address from tokenId 10 till tokenId 80.
     */
    function walletOfOwnerInRange(address owner, uint256 startTokenId, uint256 stopTokenId) public view returns (uint256[] memory ownedTokenIds) {
        require(startTokenId >= 0 && startTokenId < stopTokenId, "startTokenId must be equal to or greater than zero and smaller than stopTokenId");
        require(stopTokenId > startTokenId && stopTokenId <= totalSupply() - 1, "stopTokenId must be greater than startTokenId and smaller or equal to totalSupply - 1");
        ownedTokenIds = new uint256[](stopTokenId - startTokenId + 1);
        uint256 currentTokenId = startTokenId;
        uint256 currentTokenIndex = 0;
        while (currentTokenIndex <= stopTokenId && currentTokenId <= stopTokenId) {
            if (_exists(currentTokenId) && ownerOf(currentTokenId) == owner) {
                ownedTokenIds[currentTokenIndex] = currentTokenId;
                currentTokenIndex++;
            }
            currentTokenId++;
        }
        assembly{mstore(ownedTokenIds, currentTokenIndex)}
        return ownedTokenIds;
    }

    // INTERNAL FUNCTIONS //


    /// @notice Internal function called when requiring authorization to upgrade to a new implementation.
    function _authorizeUpgrade(address newImplementation) internal onlyOwner override {}

    /// @notice Internal function called for the calculation of rewards for the Genesis token holders.
    function _beforeTokenTransfers(address from, address to, uint256 startTokenId, uint256 quantity) internal virtual override {
        if (startTokenId >= 0 && startTokenId <= _maxSupply[1] - 1) {
            PNBB.updateReward(from, to);
            if (from != address(0)) {
                _balanceGenesis[from] -= quantity;
            }
            if (to != address(0)) {
                _balanceGenesis[to] += quantity;
            } 
        }
    }

    /// @notice Internal function called for the calculation of rewards.
    function _afterTokenTransfers(address from, address to, uint256, uint256 quantity) internal virtual override {
        PNUT.updateReward(from, to, quantity);
        YieldHub.updateReward(from, to);
    }

    /// @notice Internal function called to compare dna.
    function compareDNA(string memory a, string memory b) pure internal returns (bool) {
        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));
    }

}
