// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/TimelockControllerUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"; 

interface IProxy {
    function upgradeTo(address newImplementation) external;
}

interface IBoosterContract {
    function userBoosters(address user, uint256 boosterId) external view returns (uint256);
    function boosters(uint256 boosterId) external view returns (string memory, uint8, uint256, uint256);
}

interface IERC721 {
    function ownerOf(uint256 tokenId) external view returns (address);
}

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract LuckyAttributes is Initializable, OwnableUpgradeable, AccessControlUpgradeable, ReentrancyGuardUpgradeable, TimelockControllerUpgradeable {
    struct Attributes {
        uint256 strength;
        uint256 endurance;
        uint256 agility;
        uint256 speed;
        uint256 wisdom;
        uint256 charisma;
        uint256 intelligence;
        uint256 perception;
        uint256 luck;
        uint256 xp;
        uint256 level;
    }

    struct PendingUpgrade {
        address newContractAddress;
        uint256 proposedTime;
    }
    PendingUpgrade public pendingUpgrade;

    IBoosterContract public boosterContract;
    IERC721 public nftContract;
    IERC20 public pnutToken;

    mapping(uint256 => Attributes) public nftAttributes;
    mapping(uint256 => bool) public specialAbilityStatus;
    mapping(address => bytes32) public commitments;
    mapping(address => uint256) public lastCommitBlock;

    event UpgradeProposed(address newContractAddress, uint256 proposedTime);
    event UpgradeExecuted(address newContractAddress);
    event AttributesUpdated(uint256 indexed tokenId, Attributes newAttributes);
    event SpecialAbilityUsed(uint256 indexed tokenId, uint256 indexed abilityId);
    event Committed(address indexed user, bytes32 hash);
    event Revealed(address indexed user, uint256 number, bytes32 secret);
    event RandomEventApplied(uint256 indexed tokenId, string eventType, Attributes newAttributes);

    uint256 public constant MIN_DELAY = 1 days;
    address[] private proposers;
    address[] private executors;

    // Added a mapping to store the last called timestamp for each address
    mapping(address => uint256) public lastCalled;

    // Added a modifier for rate limiting
    modifier rateLimited() {
        require(lastCalled[msg.sender] + 1 minutes < block.timestamp, "Must wait 1 minute between calls");
        lastCalled[msg.sender] = block.timestamp;
        _;
    }

    // Added a modifier to check the legitimacy of the NFT
    modifier validNFT(uint256 tokenId) {
        require(nftContract.ownerOf(tokenId) == msg.sender, "Not the owner of the NFT");
        _;
    }

    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

    function initialize(
        address _boosterContractAddress, 
        address _nftContractAddress, 
        address _pnutTokenAddress
    ) external initializer {
        __Ownable_init();
        __ReentrancyGuard_init();
        __AccessControl_init();

        _setupRole(ADMIN_ROLE, msg.sender); // Ensure only admin can call privileged functions

        boosterContract = IBoosterContract(_boosterContractAddress);
        nftContract = IERC721(_nftContractAddress);
        pnutToken = IERC20(_pnutTokenAddress);
    }

    function initializeTimeLock() external onlyOwner {
        proposers = new address[](1);
        executors = new address[](1);
        proposers[0] = msg.sender;
        executors[0] = address(this);
        __TimelockController_init(MIN_DELAY, proposers, executors);
    }

    function proposeUpgrade(address newContractAddress) external onlyRole(ADMIN_ROLE) {
        require(newContractAddress != address(0), "New address is invalid");
        require(AddressUpgradeable.isContract(newContractAddress), "Address is not a contract");
        pendingUpgrade.newContractAddress = newContractAddress;
        pendingUpgrade.proposedTime = block.timestamp + MIN_DELAY;
        emit UpgradeProposed(newContractAddress, pendingUpgrade.proposedTime);
    }

    function executeUpgrade() external onlyRole(ADMIN_ROLE) {
        require(pendingUpgrade.newContractAddress != address(0), "No upgrade proposed");
        require(block.timestamp >= pendingUpgrade.proposedTime, "Upgrade time not reached");
        
        IProxy(address(this)).upgradeTo(pendingUpgrade.newContractAddress);
        
        emit UpgradeExecuted(pendingUpgrade.newContractAddress);
        delete pendingUpgrade;
    }

    function applyRandomEvent(uint256 tokenId, uint256 revealedNumber, uint256 boosterId) external nonReentrant validNFT(tokenId) rateLimited {
        require(revealedNumber < 1000, "Invalid revealed number");
        Attributes storage attrs = nftAttributes[tokenId];
        require(attrs.level > 0, "NFT does not exist");

        string[18] memory events = [
            "Strength Boost", "Strength Drop",
            "Endurance Boost", "Endurance Drop",
            "Agility Boost", "Agility Drop",
            "Speed Boost", "Speed Drop",
            "Wisdom Boost", "Wisdom Drop",
            "Charisma Boost", "Charisma Drop",
            "Intelligence Boost", "Intelligence Drop",
            "Perception Boost", "Perception Drop",
            "Luck Boost", "Luck Drop"
        ];
        
        string memory selectedEvent = events[revealedNumber % 18];
        uint256 change = 10; 
        
        uint256 boosterExpiration = boosterContract.userBoosters(msg.sender, boosterId);
        if (boosterExpiration > block.timestamp) {
            (, uint8 boostPercentage,,) = boosterContract.boosters(boosterId);
            change += (change * boostPercentage / 100);
        }
        
                // Implementing logic for each event...
        if (keccak256(bytes(selectedEvent)) == keccak256(bytes("Endurance Boost"))) {
            nftAttributes[tokenId].endurance += change;
        } else if (keccak256(bytes(selectedEvent)) == keccak256(bytes("Endurance Drop"))) {
            nftAttributes[tokenId].endurance = nftAttributes[tokenId].endurance > change ? nftAttributes[tokenId].endurance - change : 0;
        } else if (keccak256(bytes(selectedEvent)) == keccak256(bytes("Agility Boost"))) {
            nftAttributes[tokenId].agility += change;
        } else if (keccak256(bytes(selectedEvent)) == keccak256(bytes("Agility Drop"))) {
            nftAttributes[tokenId].agility = nftAttributes[tokenId].agility > change ? nftAttributes[tokenId].agility - change : 0;
        } else if (keccak256(bytes(selectedEvent)) == keccak256(bytes("Speed Boost"))) {
            nftAttributes[tokenId].speed += change;
        } else if (keccak256(bytes(selectedEvent)) == keccak256(bytes("Speed Drop"))) {
            nftAttributes[tokenId].speed = nftAttributes[tokenId].speed > change ? nftAttributes[tokenId].speed - change : 0;
        } else if (keccak256(bytes(selectedEvent)) == keccak256(bytes("Wisdom Boost"))) {
            nftAttributes[tokenId].wisdom += change;
        } else if (keccak256(bytes(selectedEvent)) == keccak256(bytes("Wisdom Drop"))) {
            nftAttributes[tokenId].wisdom = nftAttributes[tokenId].wisdom > change ? nftAttributes[tokenId].wisdom - change : 0;
        } else if (keccak256(bytes(selectedEvent)) == keccak256(bytes("Charisma Boost"))) {
            nftAttributes[tokenId].charisma += change;
        } else if (keccak256(bytes(selectedEvent)) == keccak256(bytes("Charisma Drop"))) {
            nftAttributes[tokenId].charisma = nftAttributes[tokenId].charisma > change ? nftAttributes[tokenId].charisma - change : 0;
        } else if (keccak256(bytes(selectedEvent)) == keccak256(bytes("Intelligence Boost"))) {
            nftAttributes[tokenId].intelligence += change;
        } else if (keccak256(bytes(selectedEvent)) == keccak256(bytes("Intelligence Drop"))) {
            nftAttributes[tokenId].intelligence = nftAttributes[tokenId].intelligence > change ? nftAttributes[tokenId].intelligence - change : 0;
        } else if (keccak256(bytes(selectedEvent)) == keccak256(bytes("Perception Boost"))) {
            nftAttributes[tokenId].perception += change;
        } else if (keccak256(bytes(selectedEvent)) == keccak256(bytes("Perception Drop"))) {
            nftAttributes[tokenId].perception = nftAttributes[tokenId].perception > change ? nftAttributes[tokenId].perception - change : 0;
        } else if (keccak256(bytes(selectedEvent)) == keccak256(bytes("Luck Boost"))) {
            nftAttributes[tokenId].luck += change;
        } else if (keccak256(bytes(selectedEvent)) == keccak256(bytes("Luck Drop"))) {
            nftAttributes[tokenId].luck = nftAttributes[tokenId].luck > change ? nftAttributes[tokenId].luck - change : 0;
        }
        
        emit RandomEventApplied(tokenId, selectedEvent, nftAttributes[tokenId]);
    }

    function useSpecialAbility(uint256 tokenId, uint256 abilityId) external validNFT(tokenId) rateLimited {
        require(specialAbilityStatus[tokenId], "Ability not available or on cooldown");
    
        Attributes storage attrs = nftAttributes[tokenId];
        if (abilityId == 1) {
            attrs.strength += 20;
        } else if (abilityId == 2) {
            attrs.speed += 10;
        }
    
        specialAbilityStatus[tokenId] = false;
    
        emit SpecialAbilityUsed(tokenId, abilityId);
        emit AttributesUpdated(tokenId, attrs);
    }

    function upgradeAttributesWithPnut(uint256 tokenId, uint256 amountToUpgrade, uint256 pnutCost) external nonReentrant validNFT(tokenId) rateLimited {
        Attributes storage attrs = nftAttributes[tokenId];
        require(pnutToken.transferFrom(msg.sender, address(this), pnutCost), "PNUT transfer failed");
        
        attrs.strength += (amountToUpgrade * 1) / (attrs.level + 1);
        
        emit AttributesUpdated(tokenId, attrs);
    }


    function commit(bytes32 hash) external rateLimited {
        commitments[msg.sender] = hash;
        lastCommitBlock[msg.sender] = block.number;
        emit Committed(msg.sender, hash);
    }
    
    function reveal(uint256 number, bytes32 secret) external rateLimited {
        bytes32 hash = keccak256(abi.encodePacked(number, secret));
        require(commitments[msg.sender] == hash, "Commitment and reveal do not match");
        require(block.number <= lastCommitBlock[msg.sender] + 100, "Reveal phase has expired");
        delete commitments[msg.sender];
        delete lastCommitBlock[msg.sender];
        emit Revealed(msg.sender, number, secret);
    }
}
